<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI åˆ†é•œç”Ÿæˆå™¨ - ä¸“ä¸šç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            scrollbar-width: thin;
            scrollbar-color: #333 #0a0a0a;
            box-sizing: border-box;
        }
        body {
            font-family: 'Noto Serif SC', serif;
            background-color: #050505;
            color: #e5e5e5;
            overflow: hidden;
            font-size: 12px;
            margin: 0;
            padding: 0;
        }
        .mono { font-family: 'JetBrains Mono', monospace; }
        .storyboard-grid {
            background-image: 
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* å·¦ä¾§å·¥ä½œæ  */
        .left-panel {
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: 100px;
            flex-shrink: 0;
        }
        .left-panel::-webkit-scrollbar { width: 4px; }
        .left-panel::-webkit-scrollbar-track { background: #0a0a0a; }
        .left-panel::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }

        .scene-item {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .scene-item:hover { border-color: #555; background: #1a1a1a; }
        .scene-item.active { border-color: #fff; background: #222; }
        .scene-item.selected-for-generate { border-left: 3px solid #10b981; }
        .scene-checkbox { margin-right: 8px; cursor: pointer; }

        /* é£æ ¼é€‰æ‹© */
        .style-option {
            background: #111;
            border: 2px solid #333;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .style-option:hover { border-color: #555; }
        .style-option.active { border-color: #10b981; background: rgba(16, 185, 129, 0.1); }
        .style-name { font-weight: bold; margin-bottom: 4px; }

        /* ä¸­é—´å†…å®¹åŒº */
        .main-content {
            flex: 1;
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            min-width: 0;
        }
        .main-content::-webkit-scrollbar { width: 8px; }
        .main-content::-webkit-scrollbar-track { background: #0a0a0a; }
        .main-content::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }

        /* è°ƒè¯•åŒºåŸŸ */
        .debug-section {
            background: #111;
            border: 1px solid #333;
            margin-bottom: 20px;
            padding: 15px;
        }
        .debug-title {
            font-size: 14px;
            color: #10b981;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .debug-image {
            max-width: 100%;
            border: 1px solid #444;
            display: block;
            margin: 10px 0;
        }

        /* åˆ†é•œç½‘æ ¼ */
        .shots-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            width: 100%;
        }

        .shot-wrapper {
            display: flex;
            flex-direction: column;
            width: 100%;
            min-width: 0;
        }

        .frame-image-box {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            background: #000;
            overflow: hidden;
            border: 1px solid #333;
        }

        .frame-image-box img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            display: block;
        }

        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #dc2626;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            font-size: 12px;
            color: #fff;
        }
        .shot-wrapper:hover .delete-btn { opacity: 1; }

        .shot-label {
            position: absolute;
            top: 6px;
            left: 6px;
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 2px 6px;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            z-index: 5;
            border-radius: 2px;
        }

        /* ç”Ÿæˆä¸­åŠ¨ç”» */
        .generating-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            gap: 12px;
        }

        .pulse-ring {
            width: 50px;
            height: 50px;
            border: 3px solid #10b981;
            border-radius: 50%;
            animation: pulse 1.5s ease-out infinite;
        }

        @keyframes pulse {
            0% { transform: scale(0.8); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-top-color: #10b981;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .generating-text {
            color: #10b981;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* ç¼–è¾‘åŒºåŸŸ */
        .frame-edit-box {
            background: #0a0a0a;
            border: 1px solid #333;
            border-top: none;
            padding: 10px;
        }

        .edit-field { margin-bottom: 10px; }
        .edit-field:last-child { margin-bottom: 0; }

        .edit-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 4px;
            display: block;
        }

        .edit-textarea {
            width: 100%;
            background: #111;
            border: 1px solid #333;
            color: #e5e5e5;
            padding: 6px 8px;
            font-size: 11px;
            line-height: 1.4;
            resize: vertical;
            min-height: 40px;
            font-family: inherit;
        }

        .edit-textarea:focus { outline: none; border-color: #555; }

        .prompt-field {
            display: flex;
            gap: 6px;
            align-items: flex-start;
        }

        .prompt-textarea {
            flex: 1;
            background: #111;
            border: 1px solid #333;
            color: #aaa;
            padding: 6px 8px;
            font-size: 10px;
            line-height: 1.3;
            resize: vertical;
            min-height: 50px;
            font-family: inherit;
        }

        .prompt-textarea:focus { outline: none; border-color: #10b981; }

        .regenerate-btn {
            background: #10b981;
            color: #000;
            border: none;
            padding: 6px 10px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .regenerate-btn:hover { background: #34d399; }
        .regenerate-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* æ·»åŠ åˆ†é•œæŒ‰é’® */
        .add-frame-box {
            aspect-ratio: 16/9;
            background: #0a0a0a;
            border: 2px dashed #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            gap: 8px;
        }

        .add-frame-box:hover { border-color: #10b981; background: rgba(16, 185, 129, 0.05); }

        .add-icon { font-size: 32px; color: #444; }
        .add-frame-box:hover .add-icon { color: #10b981; }

        /* å…¶ä»–æ ·å¼ */
        .drop-zone {
            border: 2px dashed #444;
            background: rgba(255,255,255,0.02);
            transition: all 0.3s;
        }

        .drop-zone.drag-over { border-color: #fff; background: rgba(255,255,255,0.08); }
        .drop-zone.success { border-color: #10b981; background: rgba(16, 185, 129, 0.1); }

        .btn-primary {
            background: #fff;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }

        .btn-primary:hover:not(:disabled) { background: #ccc; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-analyze {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 1px solid #444;
            color: #fff;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
        }

        .btn-analyze:hover:not(:disabled) { border-color: #10b981; }
        .btn-analyze:disabled { opacity: 0.5; cursor: not-allowed; }

        .control-group {
            background: #0a0a0a;
            border: 1px solid #333;
            padding: 10px;
            margin-bottom: 8px;
        }

        .control-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
            display: block;
        }

        select, input[type="text"], input[type="password"] {
            width: 100%;
            background: #111;
            border: 1px solid #444;
            color: #fff;
            padding: 6px;
            font-size: 11px;
        }

        .progress-container {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
            margin-top: 8px;
        }

        .progress-bar { height: 3px; background: #333; overflow: hidden; margin-bottom: 6px; }
        .progress-fill { height: 100%; background: #fff; transition: width 0.3s; }
        .progress-text { font-size: 10px; color: #888; text-align: center; }

        .status-badge {
            display: inline-block;
            padding: 2px 6px;
            font-size: 9px;
            border-radius: 2px;
            margin-left: 6px;
        }

        .status-pending { background: #333; color: #888; }
        .status-generated { background: #1e3a5f; color: #60a5fa; }

        /* å“åº”å¼ */
        @media (max-width: 1400px) { .shots-grid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 1100px) { .shots-grid { grid-template-columns: repeat(2, 1fr); } }
    </style>
</head>
<body class="storyboard-grid">
    <div class="flex h-screen">
        <!-- å·¦ä¾§å·¥ä½œæ  -->
        <div class="left-panel w-64 border-r border-neutral-800 bg-black/80">
            <div class="p-3 space-y-2">
                <!-- Header -->
                <div class="flex items-center gap-2 pb-2 border-b border-neutral-800">
                    <div class="w-7 h-7 bg-white text-black flex items-center justify-center font-black text-xs mono">16</div>
                    <div>
                        <h1 class="text-xs font-black tracking-tight">CINEMA<span class="text-neutral-500">_BOARD</span></h1>
                        <p class="text-[9px] text-neutral-500 mono">ä¸“ä¸šç‰ˆ</p>
                    </div>
                </div>

                <!-- API é…ç½® -->
                <div class="control-group">
                    <label class="control-label">API é…ç½®</label>
                    <input type="password" id="apiKey" placeholder="è¾“å…¥ APIæ˜“ Key..." class="mb-1">
                    <select id="apiEndpoint">
                        <option value="https://api.apiyi.com/v1" selected>api.apiyi.com</option>
                        <option value="https://vip.apiyi.com/v1">vip.apiyi.com</option>
                    </select>
                </div>

                <!-- å‰§æœ¬ä¸Šä¼  -->
                <div class="space-y-1">
                    <label class="control-label">å‰§æœ¬ä¸Šä¼ </label>
                    <div class="drop-zone p-2 text-center rounded cursor-pointer" id="dropZone">
                        <div class="text-base mb-0.5" id="dropIcon">ğŸ“„</div>
                        <p class="text-[10px] text-neutral-400" id="dropText">æ‹–æ‹½ Word æ–‡æ¡£</p>
                        <p class="text-[9px] text-neutral-600" id="dropSubtext">.docx / .txt</p>
                        <input type="file" id="fileInput" accept=".docx,.doc,.txt" class="hidden">
                    </div>
                </div>

                <!-- AI è§£ææŒ‰é’® -->
                <button onclick="analyzeScript()" id="analyzeBtn" disabled class="btn-analyze w-full">
                    <span id="analyzeBtnText">ğŸ§  AI è§£æåœºæ¬¡</span>
                </button>

                <!-- ç‰‡å -->
                <div class="control-group">
                    <label class="control-label">ç‰‡å</label>
                    <input type="text" id="projectTitle" placeholder="è¾“å…¥ç‰‡å...">
                </div>

                <!-- åˆ†é•œç”»é¢é£æ ¼é€‰æ‹© -->
                <div class="control-group">
                    <label class="control-label">åˆ†é•œç”»é¢é£æ ¼</label>
                    <div class="style-option active" onclick="selectStyle('bw')" id="style-bw">
                        <div class="style-name text-xs">ğŸ¨ é»‘ç™½æ•…äº‹æ¿é£æ ¼</div>
                    </div>
                    <div class="style-option" onclick="selectStyle('realistic')" id="style-realistic">
                        <div class="style-name text-xs">ğŸ¬ å†™å®ç”µå½±é£æ ¼</div>
                    </div>
                </div>

                <!-- åœºæ¬¡åˆ—è¡¨ -->
                <div id="scenesList" class="hidden">
                    <label class="control-label flex justify-between">
                        <span>åœºæ¬¡åˆ—è¡¨</span>
                        <span class="text-[9px] text-neutral-600">âœ“=é€‰æ‹©</span>
                    </label>
                    <div id="scenesContainer" class="max-h-48 overflow-y-auto"></div>
                </div>

                <!-- ç”ŸæˆæŒ‰é’® -->
                <button onclick="generate16GridStoryboard()" id="generateBtn" disabled class="btn-primary w-full">
                    ç”Ÿæˆ16æ ¼åˆ†é•œ
                </button>

                <!-- è¿›åº¦æ˜¾ç¤º -->
                <div id="progressContainer" class="progress-container hidden">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                    <div class="progress-text" id="progressText">å‡†å¤‡ç”Ÿæˆ...</div>
                </div>

                <!-- æ¸…é™¤è°ƒè¯•æŒ‰é’® -->
                <button onclick="clearDebug()" class="btn-analyze w-full mt-2">
                    æ¸…é™¤è°ƒè¯•æ˜¾ç¤º
                </button>
            </div>
        </div>

        <!-- ä¸­é—´å†…å®¹åŒº -->
        <div class="main-content" id="mainContent">
            <!-- è°ƒè¯•æ˜¾ç¤ºåŒºåŸŸ -->
            <div id="debugContainer"></div>
            
            <!-- åˆ†é•œæ˜¾ç¤ºåŒºåŸŸ -->
            <div id="storyboardContainer" class="w-full flex items-center justify-center text-neutral-600" style="min-height: 100%;">
                <div class="text-center">
                    <div class="text-4xl mb-3 opacity-20">ğŸ¬</div>
                    <p class="text-sm mb-1">ç­‰å¾…å‰§æœ¬</p>
                    <p class="text-xs">æ‹–æ‹½ Word æ–‡æ¡£ä¸Šä¼ å¹¶è§£æåœºæ¬¡</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let scenes = [];
        let currentSceneIndex = -1;
        let rawScriptText = '';
        let isGenerating = false;
        let currentStyle = 'bw';
        
        // è°ƒè¯•æ•°æ®å­˜å‚¨
        let debugData = {
            originalImage: null,
            gridOverlayImage: null,
            cutImages: []
        };
        
        const STYLE_PROMPTS = {
            bw: "Professional movie storyboard, B&W charcoal sketch style, rough marker strokes, cinematic lighting, high contrast, moody atmosphere, 2D hand-drawn aesthetic",
            realistic: "Cinematic still, hyper-realistic, dramatic natural lighting, shallow depth of field, muted cinematic color grading, high-fidelity textures, shot on 35mm lens, 8k resolution"
        };

        // æ–‡ä»¶ä¸Šä¼ 
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', () => fileInput.click());
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        dropZone.addEventListener('dragenter', () => dropZone.classList.add('drag-over'));
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
        dropZone.addEventListener('drop', (e) => {
            dropZone.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) handleFile(files[0]);
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) handleFile(e.target.files[0]);
        });

        async function handleFile(file) {
            const dropIcon = document.getElementById('dropIcon');
            const dropText = document.getElementById('dropText');
            const dropSubtext = document.getElementById('dropSubtext');

            dropZone.classList.add('drag-over');

            try {
                let text = '';
                if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) {
                    const arrayBuffer = await file.arrayBuffer();
                    const result = await mammoth.extractRawText({ arrayBuffer });
                    text = result.value;
                } else {
                    text = await file.text();
                }

                rawScriptText = text;
                dropZone.classList.remove('drag-over');
                dropZone.classList.add('success');
                dropIcon.textContent = 'âœ…';
                dropText.textContent = file.name;
                dropSubtext.textContent = `${(file.size/1024).toFixed(1)} KB`;
                document.getElementById('analyzeBtn').disabled = false;

                const titleMatch = text.match(/^(.*?)(?:\n|å‰§æœ¬|æ•…äº‹)/);
                if (titleMatch) {
                    document.getElementById('projectTitle').value = titleMatch[1].trim().substring(0, 30);
                }
            } catch (error) {
                dropZone.classList.remove('drag-over');
                dropIcon.textContent = 'âŒ';
                dropText.textContent = 'å¤±è´¥';
            }
        }

        function selectStyle(style) {
            currentStyle = style;
            document.querySelectorAll('.style-option').forEach(el => el.classList.remove('active'));
            document.getElementById(`style-${style}`).classList.add('active');
        }

        function clearDebug() {
            debugData = { originalImage: null, gridOverlayImage: null, cutImages: [] };
            document.getElementById('debugContainer').innerHTML = '';
        }

        // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
        function showDebugInfo() {
            const container = document.getElementById('debugContainer');
            let html = '';

            // 1. æ˜¾ç¤ºåŸå§‹16æ ¼å¤§å›¾
            if (debugData.originalImage) {
                html += `
                    <div class="debug-section">
                        <div class="debug-title">ã€æ­¥éª¤1ã€‘åŸå§‹16æ ¼å¤§å›¾ (1920x1080)</div>
                        <img src="${debugData.originalImage}" class="debug-image" style="max-width: 600px;">
                        <p style="color: #888; font-size: 11px;">è¿™æ˜¯AIç”Ÿæˆçš„å®Œæ•´16æ ¼å›¾ç‰‡ï¼ŒåŒ…å«é»‘è‰²åˆ†å‰²çº¿</p>
                    </div>
                `;
            }

            // 2. æ˜¾ç¤ºå¸¦ç½‘æ ¼çº¿çš„åˆ‡å‰²ç¤ºæ„å›¾
            if (debugData.gridOverlayImage) {
                html += `
                    <div class="debug-section">
                        <div class="debug-title">ã€æ­¥éª¤2ã€‘4x4ç½‘æ ¼åˆ‡å‰²ç¤ºæ„å›¾ï¼ˆè‡ªåŠ¨è¯†åˆ«é»‘è¾¹ï¼‰</div>
                        <img src="${debugData.gridOverlayImage}" class="debug-image" style="max-width: 600px;">
                        <p style="color: #888; font-size: 11px;">çº¢è‰²çº¿è¡¨ç¤ºåˆ‡å‰²ä½ç½®ï¼Œç»¿è‰²åŒºåŸŸè¡¨ç¤ºè¯†åˆ«åˆ°çš„çº¯ç”»é¢åŒºåŸŸï¼ˆå·²å»é™¤é»‘è¾¹ï¼‰</p>
                    </div>
                `;
            }

            // 3. æ˜¾ç¤ºåˆ‡å‰²åçš„æ‰€æœ‰å°å›¾
            if (debugData.cutImages.length > 0) {
                html += `
                    <div class="debug-section">
                        <div class="debug-title">ã€æ­¥éª¤3ã€‘åˆ‡å‰²åçš„åˆ†é•œç”»é¢ (480x270 16:9ï¼Œå·²å»é™¤é»‘è¾¹)</div>
                        <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 5px; margin-top: 10px;">
                `;
                debugData.cutImages.forEach((img, idx) => {
                    html += `
                        <div style="text-align: center;">
                            <img src="${img}" style="width: 100%; border: 1px solid #444;">
                            <span style="font-size: 9px; color: #666;">${idx + 1}</span>
                        </div>
                    `;
                });
                html += `</div></div>`;
            }

            container.innerHTML = html;
            // æ»šåŠ¨åˆ°é¡¶éƒ¨çœ‹è°ƒè¯•ä¿¡æ¯
            document.getElementById('mainContent').scrollTop = 0;
        }

        async function analyzeScript() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) { alert('è¯·è¾“å…¥ API Key'); return; }
            if (!rawScriptText) { alert('è¯·å…ˆä¸Šä¼ å‰§æœ¬'); return; }

            const btn = document.getElementById('analyzeBtn');
            const btnText = document.getElementById('analyzeBtnText');
            btn.disabled = true;
            btnText.textContent = 'åˆ†æä¸­...';

            try {
                const baseUrl = document.getElementById('apiEndpoint').value;
                const response = await fetch(`${baseUrl}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gemini-2.5-pro-preview-03-25',
                        messages: [{
                            role: 'user',
                            content: `åˆ†æå‰§æœ¬ï¼ŒæŒ‰åœºæ¬¡æ‹†åˆ†ã€‚è¿”å›JSONï¼š\n\n${rawScriptText.substring(0, 10000)}\n\næ ¼å¼ï¼š{\n  "title": "ç‰‡å",\n  "scenes": [{\n    "id": 1,\n    "title": "åœºæ¬¡æ ‡é¢˜",\n    "location": "åœ°ç‚¹",\n    "time": "æ—¶é—´",\n    "characters": ["è§’è‰²1", "è§’è‰²2"],\n    "shots": [{\n      "number": "01",\n      "camera": "è¿é•œç±»å‹",\n      "content": "ç”»é¢å†…å®¹",\n      "audio": "éŸ³æ•ˆ"\n    }]\n  }]\n}\næ³¨æ„ï¼šè¿é•œç±»å‹è¦ä¸“ä¸šï¼Œåªè¿”å›JSONã€‚`
                        }],
                        temperature: 0.7
                    })
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                const content = data.choices[0].message.content;
                const jsonMatch = content.match(/\{[\s\S]*\}/);

                if (jsonMatch) {
                    const parsed = JSON.parse(jsonMatch[0]);
                    applyParsedScenes(parsed);
                }
            } catch (error) {
                alert('è§£æå¤±è´¥: ' + error.message);
                btn.disabled = false;
                btnText.textContent = 'ğŸ§  AI è§£æåœºæ¬¡';
            }
        }

        function applyParsedScenes(data) {
            if (data.title) document.getElementById('projectTitle').value = data.title;

            if (data.scenes && data.scenes.length > 0) {
                scenes = data.scenes.map((scene, idx) => ({
                    ...scene,
                    selected: idx === 0,
                    shots: scene.shots.map((shot, sIdx) => ({
                        ...shot,
                        id: Date.now() + idx * 1000 + sIdx,
                        number: shot.number || String(sIdx + 1).padStart(2, '0'),
                        generatedImage: null,
                        status: 'pending',
                        isGenerating: false,
                        customPrompt: ''
                    }))
                }));

                currentSceneIndex = 0;
                renderScenesList();
                renderCurrentScene();
                document.getElementById('scenesList').classList.remove('hidden');
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('analyzeBtnText').textContent = `âœ… ${scenes.length}ä¸ªåœºæ¬¡`;
            }
        }

        function renderScenesList() {
            const container = document.getElementById('scenesContainer');
            container.innerHTML = scenes.map((scene, index) => {
                const generatedCount = scene.shots.filter(s => s.generatedImage).length;
                const statusBadge = generatedCount === scene.shots.length 
                    ? '<span class="status-badge status-generated">å·²å®Œæˆ</span>' 
                    : generatedCount > 0 
                        ? `<span class="status-badge status-generated">${generatedCount}/${scene.shots.length}</span>`
                        : '<span class="status-badge status-pending">æœªç”Ÿæˆ</span>';

                return `
                <div class="scene-item ${index === currentSceneIndex ? 'active' : ''} ${scene.selected ? 'selected-for-generate' : ''}" 
                     onclick="selectScene(${index})">
                    <div class="flex items-start">
                        <input type="checkbox" class="scene-checkbox" 
                               ${scene.selected ? 'checked' : ''} 
                               onclick="event.stopPropagation(); toggleSceneSelection(${index})">
                        <div class="flex-1 min-w-0">
                            <div class="font-bold text-xs flex items-center truncate">
                                åœºæ¬¡ ${scene.id}ï¼š${scene.location}
                                ${statusBadge}
                            </div>
                            <div class="text-[9px] text-neutral-500">${scene.time} Â· ${scene.shots.length}ä¸ªé•œå¤´</div>
                        </div>
                    </div>
                </div>
            `}).join('');
        }

        function selectScene(index) {
            currentSceneIndex = index;
            renderScenesList();
            renderCurrentScene();
        }

        function toggleSceneSelection(index) {
            scenes[index].selected = !scenes[index].selected;
            renderScenesList();
        }

        // æ¸²æŸ“å½“å‰åœºæ¬¡
        function renderCurrentScene() {
            const container = document.getElementById('storyboardContainer');

            if (currentSceneIndex === -1 || scenes.length === 0) {
                container.innerHTML = `
                    <div class="text-center">
                        <div class="text-4xl mb-3 opacity-20">ğŸ¬</div>
                        <p class="text-sm mb-1">ç­‰å¾…å‰§æœ¬</p>
                        <p class="text-xs">æ‹–æ‹½ Word æ–‡æ¡£ä¸Šä¼ å¹¶è§£æåœºæ¬¡</p>
                    </div>
                `;
                return;
            }

            const scene = scenes[currentSceneIndex];
            let html = `<div class="shots-grid">`;

            // æ¸²æŸ“æ‰€æœ‰åˆ†é•œ
            scene.shots.forEach((shot) => {
                const hasImage = shot.generatedImage;
                const isGenerating = shot.isGenerating;
                
                html += `
                    <div class="shot-wrapper">
                        <div class="frame-image-box">
                            <div class="delete-btn" onclick="deleteShot('${shot.id}')">âœ•</div>
                            <div class="shot-label">Shot ${shot.number}</div>
                            
                            ${hasImage ? `
                                <img src="${shot.generatedImage}" alt="é•œå¤´${shot.number}">
                            ` : `
                                <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#333;font-size:12px;">
                                    ${isGenerating ? '' : 'ç­‰å¾…ç”Ÿæˆ'}
                                </div>
                            `}
                            
                            ${isGenerating ? `
                                <div class="generating-overlay">
                                    <div class="pulse-ring"></div>
                                    <div class="generating-text">
                                        <div class="spinner"></div>
                                        <span>AIç”Ÿæˆä¸­...</span>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        
                        <div class="frame-edit-box">
                            <div class="edit-field">
                                <label class="edit-label">æ–‡å­—è„šæœ¬</label>
                                <textarea class="edit-textarea" 
                                    onchange="updateShotField(${currentSceneIndex}, '${shot.id}', 'content', this.value)"
                                    placeholder="è¾“å…¥é•œå¤´æè¿°...">${shot.content || ''}</textarea>
                            </div>
                            <div class="edit-field">
                                <label class="edit-label" style="color: #10b981;">æ–‡ç”Ÿå›¾æç¤ºè¯</label>
                                <div class="prompt-field">
                                    <textarea class="prompt-textarea" 
                                        id="prompt-${shot.id}"
                                        onchange="updateShotPrompt(${currentSceneIndex}, '${shot.id}', this.value)"
                                        placeholder="è¾“å…¥æç¤ºè¯...">${shot.customPrompt || ''}</textarea>
                                    <button class="regenerate-btn" 
                                            onclick="regenerateShot('${shot.id}')"
                                            ${isGenerating ? 'disabled' : ''}>
                                        ${isGenerating ? '...' : 'é‡æ–°ç”Ÿæˆ'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });

            // æ·»åŠ åˆ†é•œæŒ‰é’®
            html += `
                <div class="shot-wrapper">
                    <div class="add-frame-box" onclick="addNewShot()">
                        <div class="add-icon">â•</div>
                        <div class="text-neutral-500 text-xs">æ·»åŠ æ–°åˆ†é•œ</div>
                        <div class="text-neutral-600 text-[10px]">Shot ${String(scene.shots.length + 1).padStart(2, '0')}</div>
                    </div>
                    <div class="frame-edit-box" style="flex:1;min-height:120px;"></div>
                </div>
            </div>`;

            container.innerHTML = html;
        }

        function updateShotField(sceneIdx, shotId, field, value) {
            const scene = scenes[sceneIdx];
            const shot = scene.shots.find(s => s.id == shotId);
            if (shot) shot[field] = value;
        }

        function updateShotPrompt(sceneIdx, shotId, value) {
            const scene = scenes[sceneIdx];
            const shot = scene.shots.find(s => s.id == shotId);
            if (shot) shot.customPrompt = value;
        }

        // é‡æ–°ç”Ÿæˆåˆ†é•œ
        async function regenerateShot(shotId) {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) { alert('è¯·è¾“å…¥ API Key'); return; }

            const scene = scenes[currentSceneIndex];
            const shot = scene.shots.find(s => s.id == shotId);
            if (!shot) {
                console.error('æ‰¾ä¸åˆ°é•œå¤´:', shotId);
                return;
            }

            // è·å–æç¤ºè¯
            const promptTextarea = document.getElementById(`prompt-${shotId}`);
            const customPrompt = promptTextarea ? promptTextarea.value : shot.customPrompt;
            
            console.log('é‡æ–°ç”Ÿæˆé•œå¤´:', shot.number, 'æç¤ºè¯:', customPrompt);

            // è®¾ç½®ç”ŸæˆçŠ¶æ€
            shot.isGenerating = true;
            shot.customPrompt = customPrompt;
            renderCurrentScene();

            const baseUrl = document.getElementById('apiEndpoint').value;
            const characters = scene.characters ? scene.characters.join(', ') : 'ä¸»è¦è§’è‰²';
            const stylePrompt = STYLE_PROMPTS[currentStyle];
            
            let prompt = customPrompt;
            if (!prompt || prompt.trim() === '') {
                prompt = `${stylePrompt}. ${shot.camera || 'å…¨æ™¯'} shot, Scene: ${scene.location}, ${scene.time}. Characters: ${characters}. ${shot.content || ''}.`;
            } else {
                prompt = `${stylePrompt}. ${prompt}`;
            }

            console.log('æœ€ç»ˆæç¤ºè¯:', prompt);

            try {
                const response = await fetch(`${baseUrl}/images/generations`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gemini-3-pro-image-preview',
                        prompt: prompt,
                        size: '1024x576',
                        response_format: 'b64_json'
                    })
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();

                if (data.data && data.data[0] && data.data[0].b64_json) {
                    shot.generatedImage = `data:image/png;base64,${data.data[0].b64_json}`;
                    shot.status = 'completed';
                    console.log('ç”ŸæˆæˆåŠŸ');
                } else {
                    console.error('ç”Ÿæˆå¤±è´¥: è¿”å›æ•°æ®æ ¼å¼é”™è¯¯', data);
                    shot.status = 'error';
                }
            } catch (error) {
                console.error('ç”Ÿæˆé”™è¯¯:', error);
                shot.status = 'error';
            } finally {
                shot.isGenerating = false;
                renderCurrentScene();
                renderScenesList();
            }
        }

        function addNewShot() {
            const scene = scenes[currentSceneIndex];
            const newNumber = String(scene.shots.length + 1).padStart(2, '0');
            
            const newShot = {
                id: Date.now().toString(),
                number: newNumber,
                camera: 'å…¨æ™¯',
                content: '',
                audio: '',
                generatedImage: null,
                status: 'pending',
                isGenerating: false,
                customPrompt: ''
            };
            
            scene.shots.push(newShot);
            renderCurrentScene();
            
            setTimeout(() => {
                const container = document.getElementById('mainContent');
                container.scrollTop = container.scrollHeight;
            }, 100);
        }

        function deleteShot(shotId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåˆ†é•œå—ï¼Ÿ')) return;
            
            const scene = scenes[currentSceneIndex];
            const index = scene.shots.findIndex(s => s.id == shotId);
            if (index === -1) return;
            
            scene.shots.splice(index, 1);
            scene.shots.forEach((s, i) => {
                s.number = String(i + 1).padStart(2, '0');
            });
            
            renderCurrentScene();
            renderScenesList();
        }

        async function generate16GridStoryboard() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) { alert('è¯·è¾“å…¥ API Key'); return; }

            const selectedScenes = scenes.filter(s => s.selected);
            if (selectedScenes.length === 0) { alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªåœºæ¬¡'); return; }

            isGenerating = true;
            const btn = document.getElementById('generateBtn');
            btn.disabled = true;
            btn.textContent = 'ç”Ÿæˆä¸­...';
            document.getElementById('progressContainer').classList.remove('hidden');

            try {
                for (let i = 0; i < selectedScenes.length; i++) {
                    const scene = selectedScenes[i];
                    const sceneIdx = scenes.indexOf(scene);
                    updateProgress(i / selectedScenes.length, `æ­£åœ¨ç”Ÿæˆåœºæ¬¡ ${scene.id}... (${i+1}/${selectedScenes.length})`);
                    await generateScene16Grid(sceneIdx, apiKey);
                    renderScenesList();
                }
                updateProgress(1, 'ç”Ÿæˆå®Œæˆï¼');
                setTimeout(() => {
                    document.getElementById('progressContainer').classList.add('hidden');
                }, 2000);
            } catch (error) {
                alert('ç”Ÿæˆå‡ºé”™: ' + error.message);
            }

            isGenerating = false;
            btn.disabled = false;
            btn.textContent = 'ç”Ÿæˆ16æ ¼åˆ†é•œ';
            if (currentSceneIndex !== -1) renderCurrentScene();
        }

        function updateProgress(ratio, text) {
            document.getElementById('progressFill').style.width = `${ratio * 100}%`;
            document.getElementById('progressText').textContent = text;
        }

        async function generateScene16Grid(sceneIdx, apiKey) {
            const scene = scenes[sceneIdx];
            const shots = scene.shots;
            const totalSheets = Math.ceil(shots.length / 16);
            const baseUrl = document.getElementById('apiEndpoint').value;
            const stylePrompt = STYLE_PROMPTS[currentStyle];

            for (let sheetIdx = 0; sheetIdx < totalSheets; sheetIdx++) {
                const startIdx = sheetIdx * 16;
                const endIdx = Math.min(startIdx + 16, shots.length);
                const sheetShots = shots.slice(startIdx, endIdx);
                const actualShotCount = sheetShots.length;

                // æ ‡è®°ä¸ºç”Ÿæˆä¸­
                sheetShots.forEach(shot => shot.isGenerating = true);
                renderCurrentScene();

                // æ„å»ºæç¤ºè¯ - ä¸åŒ…å«ä»»ä½•ç¼–å·æˆ–é—´éš”ï¼Œç”»é¢ç´§å¯†æ’åˆ—
                const prompt = build16GridPrompt(scene, sheetShots, actualShotCount, stylePrompt);

                try {
                    const response = await fetch(`${baseUrl}/images/generations`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'gemini-3-pro-image-preview',
                            prompt: prompt,
                            size: '1920x1080',
                            response_format: 'b64_json'
                        })
                    });

                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();

                    if (data.data && data.data[0] && data.data[0].b64_json) {
                        const fullImage = `data:image/png;base64,${data.data[0].b64_json}`;
                        
                        // ä¿å­˜è°ƒè¯•æ•°æ®
                        debugData.originalImage = fullImage;
                        
                        // è‡ªåŠ¨è¯†åˆ«é»‘è¾¹å¹¶åˆ‡å‰²
                        const cutResult = await cut16GridWithAutoCrop(fullImage, actualShotCount);
                        debugData.cutImages = cutResult.frames;
                        debugData.gridOverlayImage = cutResult.overlayImage;
                        
                        // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                        showDebugInfo();

                        // åªåˆ†é…å®é™…æœ‰ç”»é¢çš„åˆ†é•œï¼ˆæ’é™¤ç©ºç™½æ ¼ï¼‰
                        sheetShots.forEach((shot, idx) => {
                            if (cutResult.frames[idx]) {
                                shot.generatedImage = cutResult.frames[idx];
                                shot.status = 'completed';
                            }
                            shot.isGenerating = false;
                        });
                        
                        renderCurrentScene();
                    }
                } catch (error) {
                    console.error('ç”Ÿæˆé”™è¯¯:', error);
                    sheetShots.forEach(shot => {
                        shot.status = 'error';
                        shot.isGenerating = false;
                    });
                    renderCurrentScene();
                }
            }
        }

        // æ„å»º16æ ¼æç¤ºè¯ - ä¸åŒ…å«ä»»ä½•ç¼–å·ï¼Œç”»é¢ç´§å¯†æ’åˆ—ï¼Œç”¨é»‘è‰²åˆ†å‰²çº¿åˆ†éš”
        function build16GridPrompt(scene, shots, actualCount, stylePrompt) {
            const characters = scene.characters ? scene.characters.join(', ') : 'ä¸»è¦è§’è‰²';
            
            // ä¸ºæ¯ä¸ªå®é™…é•œå¤´æ„å»ºæè¿°
            let shotDescriptions = [];
            for (let i = 0; i < actualCount; i++) {
                const shot = shots[i];
                const content = shot.customPrompt || `${shot.camera || 'å…¨æ™¯'}: ${shot.content || ''}`;
                shotDescriptions.push(content);
            }

            // å…³é”®æç¤ºè¯ï¼šä½¿ç”¨é»‘è‰²åˆ†å‰²çº¿åˆ†éš”ï¼Œæ— ç¼–å·ï¼Œæ— é—´éš”ï¼Œç´§å¯†æ’åˆ—
            return `${stylePrompt}. Film storyboard contact sheet layout: 4x4 grid with 16 frames total. 
Strict requirements: 
- Each frame is exactly 480x270 pixels (16:9 aspect ratio)
- Total image size 1920x1080 pixels
- Use pure black lines (3px width) as separators between all frames
- NO numbers, NO text, NO labels inside any frame
- NO spacing between frames, only black separator lines
- Frames arranged tightly in 4 rows and 4 columns
- If less than 16 shots, remaining frames should be blank/empty with black borders only
- Each frame must show: cinematic composition, professional film lighting

Scene location: ${scene.location}, Time: ${scene.time}
Characters: ${characters}
Shots to depict (only first ${actualCount} frames have content): ${shotDescriptions.join(' | ')}`;
        }

        // è‡ªåŠ¨è¯†åˆ«é»‘è¾¹å¹¶åˆ‡å‰²16æ ¼
        async function cut16GridWithAutoCrop(fullImageUrl, actualShotCount) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // åˆ†æåƒç´ äº®åº¦ï¼Œæ£€æµ‹é»‘è‰²åˆ†å‰²çº¿ä½ç½®
                    // é»‘è‰²åˆ†å‰²çº¿ç‰¹å¾ï¼šRGBéƒ½æ¥è¿‘0ï¼Œä¸”å½¢æˆè¿ç»­çš„çº¿
                    
                    // 1. æ£€æµ‹æ°´å¹³é»‘çº¿ä½ç½®ï¼ˆæ¨ªå‘æ‰«æï¼‰
                    const horizontalLines = [];
                    const threshold = 30; // è®¤ä¸ºæ˜¯é»‘è‰²çš„é˜ˆå€¼
                    
                    for (let y = 0; y < canvas.height; y++) {
                        let blackPixelCount = 0;
                        for (let x = 0; x < canvas.width; x++) {
                            const idx = (y * canvas.width + x) * 4;
                            if (data[idx] < threshold && data[idx + 1] < threshold && data[idx + 2] < threshold) {
                                blackPixelCount++;
                            }
                        }
                        // å¦‚æœä¸€è¡Œä¸­80%ä»¥ä¸Šåƒç´ æ˜¯é»‘è‰²ï¼Œè®¤ä¸ºæ˜¯åˆ†å‰²çº¿
                        if (blackPixelCount > canvas.width * 0.8) {
                            horizontalLines.push(y);
                        }
                    }
                    
                    // 2. æ£€æµ‹å‚ç›´é»‘çº¿ä½ç½®ï¼ˆçºµå‘æ‰«æï¼‰
                    const verticalLines = [];
                    for (let x = 0; x < canvas.width; x++) {
                        let blackPixelCount = 0;
                        for (let y = 0; y < canvas.height; y++) {
                            const idx = (y * canvas.width + x) * 4;
                            if (data[idx] < threshold && data[idx + 1] < threshold && data[idx + 2] < threshold) {
                                blackPixelCount++;
                            }
                        }
                        if (blackPixelCount > canvas.height * 0.8) {
                            verticalLines.push(x);
                        }
                    }
                    
                    // 3. åˆå¹¶æ¥è¿‘çš„çº¿æ¡ï¼ˆå»é‡ï¼‰
                    const mergeLines = (lines, minDistance = 5) => {
                        if (lines.length === 0) return [];
                        const merged = [lines[0]];
                        for (let i = 1; i < lines.length; i++) {
                            if (lines[i] - merged[merged.length - 1] > minDistance) {
                                merged.push(lines[i]);
                            }
                        }
                        return merged;
                    };
                    
                    const hLines = mergeLines(horizontalLines);
                    const vLines = mergeLines(verticalLines);
                    
                    // 4. å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°è¶³å¤Ÿçš„çº¿æ¡ï¼Œä½¿ç”¨æ ‡å‡†480x270ç½‘æ ¼
                    let rowBoundaries, colBoundaries;
                    
                    if (hLines.length >= 3 && vLines.length >= 3) {
                        // ä½¿ç”¨æ£€æµ‹åˆ°çš„é»‘çº¿ä½œä¸ºè¾¹ç•Œ
                        // éœ€è¦æ‰¾åˆ°4ä¸ªåŒºåŸŸçš„è¾¹ç•Œï¼ˆ5æ¡çº¿ï¼šä¸Šã€ä¸­1ã€ä¸­2ã€ä¸­3ã€ä¸‹ï¼‰
                        rowBoundaries = [0, ...hLines, canvas.height];
                        colBoundaries = [0, ...vLines, canvas.width];
                        
                        // ç¡®ä¿åªæœ‰5ä¸ªè¾¹ç•Œï¼ˆ4ä¸ªåŒºåŸŸï¼‰
                        if (rowBoundaries.length > 5) {
                            // å–æœ€å¯èƒ½çš„3æ¡ä¸­é—´çº¿ï¼ˆåŸºäºå‡åŒ€åˆ†å¸ƒï¼‰
                            const step = canvas.height / 4;
                            rowBoundaries = [0];
                            for (let i = 1; i < 4; i++) {
                                // æ‰¾åˆ°æœ€æ¥è¿‘ç†è®ºä½ç½®çš„çº¿
                                const target = i * step;
                                const closest = hLines.reduce((prev, curr) => 
                                    Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev
                                );
                                rowBoundaries.push(closest);
                            }
                            rowBoundaries.push(canvas.height);
                        }
                        
                        if (colBoundaries.length > 5) {
                            const step = canvas.width / 4;
                            colBoundaries = [0];
                            for (let i = 1; i < 4; i++) {
                                const target = i * step;
                                const closest = vLines.reduce((prev, curr) => 
                                    Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev
                                );
                                colBoundaries.push(closest);
                            }
                            colBoundaries.push(canvas.width);
                        }
                    } else {
                        // ä½¿ç”¨æ ‡å‡†ç½‘æ ¼ï¼ˆå‡è®¾å›¾åƒæ˜¯1920x1080ï¼Œæ¯ä¸ªæ ¼å­480x270ï¼‰
                        rowBoundaries = [0, 270, 540, 810, 1080];
                        colBoundaries = [0, 480, 960, 1440, 1920];
                    }
                    
                    // 5. åˆ‡å‰²å›¾ç‰‡ï¼ˆè·³è¿‡é»‘è¾¹ï¼Œåªå–çº¯ç”»é¢ï¼‰
                    const frames = [];
                    const targetWidth = 480;
                    const targetHeight = 270;
                    
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            const idx = row * 4 + col;
                            if (idx >= actualShotCount) break; // åªå¤„ç†å®é™…æœ‰ç”»é¢çš„åˆ†é•œ
                            
                            // è®¡ç®—çº¯ç”»é¢åŒºåŸŸï¼ˆå»é™¤é»‘è¾¹ï¼‰
                            const startY = rowBoundaries[row] + 3; // +3è·³è¿‡é»‘çº¿
                            const endY = rowBoundaries[row + 1] - 3;
                            const startX = colBoundaries[col] + 3;
                            const endX = colBoundaries[col + 1] - 3;
                            
                            const contentWidth = endX - startX;
                            const contentHeight = endY - startY;
                            
                            // åˆ›å»ºç›®æ ‡å°ºå¯¸ç”»å¸ƒ
                            const frameCanvas = document.createElement('canvas');
                            frameCanvas.width = targetWidth;
                            frameCanvas.height = targetHeight;
                            const frameCtx = frameCanvas.getContext('2d');
                            
                            // å¡«å……é»‘è‰²èƒŒæ™¯ï¼ˆé˜²æ­¢ç©ºç™½åŒºåŸŸé€æ˜ï¼‰
                            frameCtx.fillStyle = '#000000';
                            frameCtx.fillRect(0, 0, targetWidth, targetHeight);
                            
                            // ç»˜åˆ¶çº¯ç”»é¢å†…å®¹ï¼Œæ‹‰ä¼¸/ç¼©æ”¾ä»¥é€‚åº”480x270
                            frameCtx.drawImage(
                                img,
                                startX, startY, contentWidth, contentHeight,
                                0, 0, targetWidth, targetHeight
                            );
                            
                            frames.push(frameCanvas.toDataURL('image/png'));
                        }
                    }
                    
                    // 6. ç”Ÿæˆå¸¦ç½‘æ ¼çº¿çš„è°ƒè¯•å›¾ï¼ˆæ˜¾ç¤ºæ£€æµ‹åˆ°çš„è¾¹ç•Œï¼‰
                    const debugCanvas = document.createElement('canvas');
                    debugCanvas.width = img.width;
                    debugCanvas.height = img.height;
                    const debugCtx = debugCanvas.getContext('2d');
                    debugCtx.drawImage(img, 0, 0);
                    
                    // ç»˜åˆ¶æ£€æµ‹åˆ°çš„åˆ‡å‰²çº¿ï¼ˆçº¢è‰²ï¼‰
                    debugCtx.strokeStyle = 'red';
                    debugCtx.lineWidth = 2;
                    
                    // æ°´å¹³çº¿
                    rowBoundaries.forEach(y => {
                        debugCtx.beginPath();
                        debugCtx.moveTo(0, y);
                        debugCtx.lineTo(debugCanvas.width, y);
                        debugCtx.stroke();
                    });
                    
                    // å‚ç›´çº¿
                    colBoundaries.forEach(x => {
                        debugCtx.beginPath();
                        debugCtx.moveTo(x, 0);
                        debugCtx.lineTo(x, debugCanvas.height);
                        debugCtx.stroke();
                    });
                    
                    // æ ‡è®°çº¯ç”»é¢åŒºåŸŸï¼ˆç»¿è‰²åŠé€æ˜é®ç½©ï¼‰
                    debugCtx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            const startY = rowBoundaries[row] + 3;
                            const endY = rowBoundaries[row + 1] - 3;
                            const startX = colBoundaries[col] + 3;
                            const endX = colBoundaries[col + 1] - 3;
                            debugCtx.fillRect(startX, startY, endX - startX, endY - startY);
                        }
                    }
                    
                    const overlayImage = debugCanvas.toDataURL('image/png');
                    
                    resolve({
                        frames: frames,
                        overlayImage: overlayImage,
                        rowBoundaries: rowBoundaries,
                        colBoundaries: colBoundaries
                    });
                };
                img.src = fullImageUrl;
            });
        }

        window.addEventListener('load', () => {
            document.getElementById('apiKey').value = localStorage.getItem('apiyi_key') || '';
        });
        document.getElementById('apiKey').addEventListener('change', (e) => {
            localStorage.setItem('apiyi_key', e.target.value);
        });
    </script>
</body>
</html>
